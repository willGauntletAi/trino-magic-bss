# endpoints.json Structure Documentation

This document explains the structure of the `endpoints.json` file generated by the OpenAPI parser. This file contains all the parsed endpoints from TMF API specifications, organized by tag, along with their underlying data types and schema information.

## Overview

The `endpoints.json` file is an object where each key is a tag name from the OpenAPI specifications, and each value is a `TaggedEndpointGroup` object. This structure makes it easy to look up endpoint information by tag name.

## Structure

The top-level structure of `endpoints.json` is:

```json
{
  "TroubleTicket": {
    "tableName": "TroubleTicket",
    "endpoints": [...],
    "underlyingType": "TroubleTicket",
    "schema": {...}
  },
  "ProductOffering": {
    "tableName": "ProductOffering",
    "endpoints": [...],
    "underlyingType": "ProductOffering",
    "schema": {...}
  },
  // Other tag groups...
}
```

### TaggedEndpointGroup Fields

Each value in the top-level object is a `TaggedEndpointGroup` with the following structure:

| Field | Type | Description |
|-------|------|-------------|
| `tableName` | string | A CamelCase representation of the tag, suitable for database table naming |
| `endpoints` | array | List of all endpoints associated with this tag |
| `underlyingType` | string | The primary data type name for this resource (optional) |
| `schema` | object | Complete schema definition for the resource type (optional) |

## Endpoints Array

The `endpoints` array contains objects representing each individual API endpoint:

```json
"endpoints": [
  {
    "operationId": "retrieveTroubleTicket",
    "path": "/troubleTicket/{id}",
    "method": "get"
  },
  {
    "operationId": "listTroubleTicket",
    "path": "/troubleTicket",
    "method": "get"
  }
]
```

| Field | Type | Description |
|-------|------|-------------|
| `operationId` | string | The unique operation identifier from the API spec |
| `path` | string | The URL path pattern of the endpoint |
| `method` | string | The HTTP method (get, post, patch, delete, etc.) |

## Schema Structure

The `schema` field contains the complete type definition for the resource, including all fields, types, and nested structures. This is the most complex part of the output and follows this structure:

```json
"schema": {
  "name": "TroubleTicket",
  "description": "A trouble ticket is a record of an issue...",
  "fields": {...},
  "required": [...],
  "oneOf": [...] // For schemas with oneOf variants
}
```

### Schema Fields

| Field | Type | Description |
|-------|------|-------------|
| `name` | string | The name of the schema type |
| `description` | string | A description of the schema type (if available) |
| `fields` | object | A map of all fields in the schema |
| `required` | array | An array of field names that are required |
| `oneOf` | array | Optional array of variant schemas for polymorphic types |

### Fields Object

The `fields` object contains key-value pairs where:
- The key is the field name
- The value is a `SchemaField` object that defines the field's type and properties

Example:

```json
"fields": {
  "id": {
    "name": "id",
    "type": "string",
    "description": "Unique identifier"
  },
  "status": {
    "name": "status",
    "type": "string",
    "description": "The current status of the trouble ticket"
  }
}
```

### SchemaField Structure

Each field in the `fields` object has the following structure:

```json
{
  "name": "fieldName",
  "type": "string", // or "object", "array", "boolean", "number", "union", etc.
  "description": "Description of the field",
  "format": "date-time", // optional
  "enum": ["value1", "value2"], // optional
  "properties": {...}, // for object types
  "items": {...}, // for array types
  "required": true, // optional, indicates if this specific field is required
  "oneOf": [...] // optional, for union types with variants
}
```

| Field | Type | Description |
|-------|------|-------------|
| `name` | string | The name of the field |
| `type` | string | The data type of the field (string, object, array, number, boolean, union, etc.) |
| `description` | string | A description of the field (if available) |
| `format` | string | Optional format specification (e.g., date-time, email, uuid) |
| `enum` | array | Optional array of allowed values for the field |
| `properties` | object | For object types, contains nested fields |
| `items` | object | For array types, describes the type of items in the array |
| `required` | boolean | Indicates if this specific field is required |
| `oneOf` | array | For union types, contains the possible variant schemas |

### Nested Objects

For fields with `type: "object"`, the `properties` field contains a map of nested fields:

```json
"address": {
  "name": "address",
  "type": "object",
  "properties": {
    "street": {
      "name": "street",
      "type": "string"
    },
    "city": {
      "name": "city",
      "type": "string"
    }
  }
}
```

### Array Fields

For fields with `type: "array"`, the `items` field describes the type of items in the array:

```json
"relatedParty": {
  "name": "relatedParty",
  "type": "array",
  "items": {
    "name": "items",
    "type": "object",
    "properties": {
      "id": {
        "name": "id",
        "type": "string"
      },
      "role": {
        "name": "role",
        "type": "string"
      }
    }
  }
}
```

### Expanded References

All `$ref` references in the original OpenAPI specification are fully expanded in the schema. This means that instead of seeing reference objects like `{ "$ref": "#/components/schemas/SomeType" }`, you'll see the complete expanded schema structure.

For example, a field that originally referenced another schema:

```yaml
attachment:
  $ref: '#/components/schemas/AttachmentRefOrValue'
```

Will be expanded to include all fields from `AttachmentRefOrValue`:

```json
"attachment": {
  "name": "attachment",
  "type": "object",
  "description": "Resolved from reference: AttachmentRefOrValue",
  "properties": {
    "id": {
      "name": "id",
      "type": "string"
    },
    "href": {
      "name": "href",
      "type": "string"
    },
    // ... other fields from AttachmentRefOrValue
  }
}
```

## Example

Here's a simplified example of the `endpoints.json` structure:

```json
{
  "TroubleTicket": {
    "tableName": "TroubleTicket",
    "endpoints": [
      {
        "operationId": "listTroubleTicket",
        "path": "/troubleTicket",
        "method": "get"
      },
      {
        "operationId": "retrieveTroubleTicket",
        "path": "/troubleTicket/{id}",
        "method": "get"
      }
    ],
    "underlyingType": "TroubleTicket",
    "schema": {
      "name": "TroubleTicket",
      "description": "A trouble ticket is a record of an issue...",
      "fields": {
        "id": {
          "name": "id",
          "type": "string",
          "description": "Unique identifier"
        },
        "status": {
          "name": "status",
          "type": "string",
          "description": "The current status"
        },
        "relatedParty": {
          "name": "relatedParty",
          "type": "array",
          "description": "List of parties related to this ticket",
          "items": {
            "name": "items",
            "type": "object",
            "properties": {
              "id": {
                "name": "id",
                "type": "string"
              },
              "role": {
                "name": "role",
                "type": "string"
              }
            }
          }
        }
      },
      "required": ["id", "status"]
    }
  }
}
```

## Usage

This structured data can be used to:

1. Generate database schemas for each resource type
2. Create API clients with proper typing
3. Generate documentation for the TMF APIs
4. Build Trino connectors for accessing and querying the data
5. Create mock data services for testing

The expanded schema information provides all the necessary details to understand the structure of each resource type, its relationships, and validation requirements.

## Implementation Note

The structure described in this document reflects how the `endpoints.json` file is currently implemented in the code. The object uses tag names as keys for quick lookup, rather than using an array with explicit tag fields.

### Union Types and Polymorphism

The parser handles polymorphic types using the `oneOf` pattern from OpenAPI specifications. When a field or schema can be one of several variants, it is represented as follows:

1. The field's `type` is set to `"union"`
2. The field includes a `oneOf` array containing all possible variants
3. Each variant in the `oneOf` array is a complete schema definition

Example of a field with `oneOf`:

```json
"attachment": {
  "name": "attachment",
  "type": "array",
  "items": {
    "name": "items",
    "type": "union",
    "description": "The polymorphic attachment type",
    "oneOf": [
      {
        "name": "items_variant_0",
        "type": "object",
        "description": "Full attachment with content",
        "properties": {
          "id": {
            "name": "id",
            "type": "string"
          },
          "content": {
            "name": "content",
            "type": "string",
            "format": "base64"
          }
        }
      },
      {
        "name": "items_variant_1",
        "type": "object",
        "description": "Attachment reference",
        "properties": {
          "href": {
            "name": "href",
            "type": "string"
          }
        }
      }
    ]
  }
}
```

In this example:
- The `attachment` field is an array where each item can be one of two variants
- The items are marked as type `"union"` to indicate polymorphism
- Each variant in the `oneOf` array has its own complete schema definition
- Variants are named with suffixes (`_variant_0`, `_variant_1`) for clarity
- Each variant maintains its own properties, descriptions, and nested structures

This structure allows for accurate representation of polymorphic types while maintaining type safety and clear documentation of all possible variants.

Note: Currently, `anyOf` patterns are not explicitly supported and are treated as `oneOf` for simplicity and type safety. This is because `anyOf` allows multiple variants to be valid simultaneously, which can lead to ambiguous type definitions.
