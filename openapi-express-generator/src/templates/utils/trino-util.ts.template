import { Trino, BasicAuth } from 'trino-client';

// Configuration for Trino connection
const trinoConfig = {
  server: `http://${process.env.TRINO_HOST || 'localhost'}:${process.env.TRINO_PORT || '8080'}`,
  catalog: process.env.TRINO_CATALOG || 'sheets', // Default to sheets catalog
  schema: process.env.TRINO_SCHEMA || 'default',
  // Basic auth if user is provided
  auth: process.env.TRINO_USER ? new BasicAuth(process.env.TRINO_USER) : undefined,
  // Additional headers according to the Trino protocol documentation
  headers: {
    'X-Trino-Source': 'trino-express-api',
    'X-Trino-Client-Info': 'Generated Express API'
  }
};

// Create a Trino client instance
const trino = Trino.create(trinoConfig);

/**
 * Execute a query against Trino
 * @param query SQL query to execute
 * @returns Promise that resolves to the query results
 */
export async function executeQuery<T = any>(query: string): Promise<T[]> {
  try {
    // Only log the actual SQL query
    console.log(`Executing Trino query: ${query}`);
    const iterator = await trino.query(query);
    
    // Fetch all results
    const results: T[] = [];
    for await (const result of iterator) {
      if (result.data) {
        results.push(...(result.data as T[]));
      }
    }
    
    return results;
  } catch (error) {
    // Keep error logging for debugging purposes
    console.error('Error executing Trino query:', error);
    throw error;
  }
}

/**
 * Build a simple SELECT query
 * @param table The table name to query
 * @param columns Array of column names to select
 * @param whereClause Optional WHERE clause
 * @param limit Optional LIMIT clause
 * @returns A SQL query string
 */
export function buildSelectQuery(
  table: string, 
  columns: string[] = ['*'], 
  whereClause?: string, 
  limit?: number
): string {
  console.log(`[DEBUG] Building SELECT query:
    - Input table name: "${table}"
    - Columns: ${columns.join(', ')}
    - Where clause: ${whereClause || 'none'}
    - Limit: ${limit || 'none'}`);

  // Preserve case sensitivity in table names
  const quotedTable = table;  // The table name is already properly cased from the controller
  let query = `SELECT ${columns.join(', ')} FROM "${trinoConfig.catalog}"."${trinoConfig.schema}"."${quotedTable}"`;
  
  if (whereClause) {
    query += ` WHERE ${whereClause}`;
  }
  
  if (limit) {
    query += ` LIMIT ${limit}`;
  }

  console.log(`[DEBUG] Generated SQL query: ${query}`);
  
  return query;
}

/**
 * Get a record by ID
 * @param table The table name
 * @param id The ID value
 * @param idColumn The column name for the ID
 * @returns Promise resolving to the record
 */
export async function getById<T = any>(
  table: string, 
  id: string | number, 
  idColumn: string = 'id'
): Promise<T | null> {
  const idValue = typeof id === 'string' ? `'${id}'` : id;
  const query = buildSelectQuery(table, ['*'], `${idColumn} = ${idValue}`);
  
  const results = await executeQuery<T>(query);
  return results.length > 0 ? results[0] : null;
}

/**
 * Get records with pagination
 * @param table The table name
 * @param limit Maximum number of records to return
 * @param offset Number of records to skip
 * @param whereClause Optional WHERE clause
 * @returns Promise resolving to records array
 */
export async function getRecords<T = any>(
  table: string,
  limit: number = 100,
  offset: number = 0,
  whereClause?: string
): Promise<T[]> {
  console.log(`[DEBUG] getRecords called with:
    - Table name: "${table}"
    - Limit: ${limit}
    - Offset: ${offset}
    - Where clause: ${whereClause || 'none'}`);

  const limitClause = limit > 0 ? limit : 100;
  const query = whereClause
    ? `${buildSelectQuery(table, ['*'], whereClause)} LIMIT ${limitClause} OFFSET ${offset}`
    : `${buildSelectQuery(table, ['*'])} LIMIT ${limitClause} OFFSET ${offset}`;
  
  return executeQuery<T>(query);
}

/**
 * Execute a direct SQL query with a custom catalog/schema
 * @param sql The SQL query to execute
 * @param catalog Optional catalog to use (overrides the default)
 * @param schema Optional schema to use (overrides the default)
 * @returns Promise resolving to the query results
 */
export async function executeSql<T = any>(
  sql: string,
  catalog?: string,
  schema?: string
): Promise<T[]> {
  try {
    // Create a custom client with the specified catalog/schema if provided
    const customConfig = { ...trinoConfig };
    if (catalog) customConfig.catalog = catalog;
    if (schema) customConfig.schema = schema;
    
    const customClient = Trino.create(customConfig);
    const iterator = await customClient.query(sql);
    
    // Fetch all results
    const results: T[] = [];
    for await (const result of iterator) {
      if (result.data) {
        results.push(...(result.data as T[]));
      }
    }
    
    return results;
  } catch (error) {
    console.error(`Error executing SQL query "${sql}":`, error);
    throw error;
  }
} 