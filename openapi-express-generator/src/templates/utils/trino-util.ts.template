import { Trino, BasicAuth } from 'trino-client';

// Configuration for Trino connection
const trinoConfig = {
  server: `http://${process.env.TRINO_HOST || 'localhost'}:${process.env.TRINO_PORT || '8080'}`,
  catalog: process.env.TRINO_CATALOG || 'sheets', // Default to sheets catalog
  schema: process.env.TRINO_SCHEMA || 'default',
  // Basic auth if user is provided
  auth: process.env.TRINO_USER ? new BasicAuth(process.env.TRINO_USER) : undefined,
  // Additional headers according to the Trino protocol documentation
  headers: {
    'X-Trino-Source': 'trino-express-api',
    'X-Trino-Client-Info': 'Generated Express API'
  }
};

// Create a Trino client instance
const trino = Trino.create(trinoConfig);

/**
 * Execute a query against Trino
 * @param query SQL query to execute
 * @returns Promise that resolves to the query results and column metadata
 */
export async function executeQuery<T = any>(query: string): Promise<{ data: T[]; columns: { name: string; type: string }[] }> {
  try {
    // Only log the actual SQL query
    console.log(`Executing Trino query: ${query}`);
    const iterator = await trino.query(query);
    
    let columns: { name: string; type: string }[] = [];
    const results: T[] = [];

    for await (const result of iterator) {
      console.log('[DEBUG] Trino result chunk:', JSON.stringify(result, null, 2));
      
      // Get column metadata from the first result
      if (!columns.length && result.columns) {
        columns = result.columns.map(col => ({
          name: col.name,
          type: col.type
        }));
        console.log('[DEBUG] Column metadata:', JSON.stringify(columns, null, 2));
      }
      
      if (result.data) {
        console.log('[DEBUG] Data in this chunk:', JSON.stringify(result.data, null, 2));
        results.push(...(result.data as T[]));
      }
    }
    
    console.log('[DEBUG] Final transformed results:', JSON.stringify(results, null, 2));
    return { data: results, columns };
  } catch (error) {
    // Keep error logging for debugging purposes
    console.error('Error executing Trino query:', error);
    throw error;
  }
}

/**
 * Build a simple SELECT query
 * @param table The table name to query
 * @param columns Array of column names to select
 * @param whereClause Optional WHERE clause
 * @param limit Optional LIMIT clause
 * @returns A SQL query string
 */
export function buildSelectQuery(
  table: string, 
  columns: string[] = ['*'], 
  whereClause?: string, 
  limit?: number
): string {
  console.log(`[DEBUG] Building SELECT query:
    - Input table name: "${table}"
    - Columns: ${columns.join(', ')}
    - Where clause: ${whereClause || 'none'}
    - Limit: ${limit || 'none'}`);

  // Preserve case sensitivity in table names
  const quotedTable = table;  // The table name is already properly cased from the controller
  let query = `SELECT ${columns.join(', ')} FROM "${trinoConfig.catalog}"."${trinoConfig.schema}"."${quotedTable}"`;
  
  if (whereClause) {
    query += ` WHERE ${whereClause}`;
  }
  
  if (limit) {
    query += ` LIMIT ${limit}`;
  }

  console.log(`[DEBUG] Generated SQL query: ${query}`);
  
  return query;
}

/**
 * Get a record by ID
 * @param table The table name
 * @param id The ID value
 * @param idColumn The column name for the ID
 * @returns Promise resolving to the record
 */
export async function getById<T = any>(
  table: string, 
  id: string | number, 
  idColumn: string = 'id'
): Promise<T | null> {
  const idValue = typeof id === 'string' ? `'${id}'` : id;
  const query = buildSelectQuery(table, ['*'], `${idColumn} = ${idValue}`);
  
  const { data, columns } = await executeQuery<T>(query);
  
  if (data.length === 0) return null;
  
  const record = data[0];
  if (Array.isArray(record)) {
    return columns.reduce((obj, col, index) => {
      obj[col.name] = record[index];
      return obj;
    }, {} as any);
  }
  return record;
}

/**
 * Get records with pagination
 * @param table The table name
 * @param limit Maximum number of records to return
 * @param offset Number of records to skip
 * @param whereClause Optional WHERE clause
 * @returns Promise resolving to records array
 */
export async function getRecords<T = any>(
  table: string,
  limit: number = 100,
  offset: number = 0,
  whereClause?: string
): Promise<T[]> {
  console.log(`[DEBUG] getRecords called with:
    - Table name: "${table}"
    - Limit: ${limit}
    - Offset: ${offset}
    - Where clause: ${whereClause || 'none'}`);

  const limitClause = limit > 0 ? limit : 100;
  
  // Build the query with proper ORDER BY, OFFSET, LIMIT sequence
  let query = `SELECT * FROM "${trinoConfig.catalog}"."${trinoConfig.schema}"."${table}"`;
  if (whereClause) {
    query += ` WHERE ${whereClause}`;
  }
  if (offset > 0) {
    query += ` OFFSET ${offset} ROWS`;
  }
  if (limitClause) {
    query += ` LIMIT ${limitClause}`;
  }

  console.log('[DEBUG] Executing query:', query);
  
  const { data, columns } = await executeQuery<T>(query);
  console.log('[DEBUG] Raw data from Trino:', JSON.stringify(data, null, 2));
  console.log('[DEBUG] Columns from Trino:', JSON.stringify(columns, null, 2));
  
  // Transform array results into objects using column metadata
  const transformedResults = data.map(record => {
    if (Array.isArray(record)) {
      const transformed = columns.reduce((obj, col, index) => {
        obj[col.name] = record[index];
        return obj;
      }, {} as any);
      console.log('[DEBUG] Transformed record:', JSON.stringify(transformed, null, 2));
      return transformed;
    }
    return record;
  });
  
  console.log('[DEBUG] Final transformed results:', JSON.stringify(transformedResults, null, 2));
  return transformedResults;
}

/**
 * Execute a direct SQL query with a custom catalog/schema
 * @param sql The SQL query to execute
 * @param catalog Optional catalog to use (overrides the default)
 * @param schema Optional schema to use (overrides the default)
 * @returns Promise resolving to the query results
 */
export async function executeSql<T = any>(
  sql: string,
  catalog?: string,
  schema?: string
): Promise<T[]> {
  try {
    // Create a custom client with the specified catalog/schema if provided
    const customConfig = { ...trinoConfig };
    if (catalog) customConfig.catalog = catalog;
    if (schema) customConfig.schema = schema;
    
    const customClient = Trino.create(customConfig);
    const iterator = await customClient.query(sql);
    
    // Fetch all results
    const results: T[] = [];
    for await (const result of iterator) {
      if (result.data) {
        results.push(...(result.data as T[]));
      }
    }
    
    return results;
  } catch (error) {
    console.error(`Error executing SQL query "${sql}":`, error);
    throw error;
  }
} 